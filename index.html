<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wooden Tic-Tac-Toe</title>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Сцена, камера и рендерер
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 800);
camera.position.set(0.8, 3, 4);
camera.lookAt(0.2, -0.1, 0.7);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Загрузка текстуры дерева
const textureLoader = new THREE.TextureLoader();
const woodTexture = textureLoader.load('./wood.jpg');
const stoneTexture = textureLoader.load('./stone.jpg');
let board;

// Создаем доску с наклоном
function createBoard() {
    const boardGeometry = new THREE.BoxGeometry(3.2, 0.25, 3.2);
    const boardMaterial = new THREE.MeshStandardMaterial({ map: woodTexture });
    board = new THREE.Mesh(boardGeometry, boardMaterial);
    board.position.y = -0.18;
    board.rotation.x = Math.PI / 110; // Наклон доски на 5 градусов к зрителю
    scene.add(board);

    // Канавки для сетки
    const grooveMaterial = new THREE.MeshStandardMaterial({ color: 0x3b2400, map: woodTexture });
    
    const grooveDepth = -0.04; // Насколько углублены канавки
    const grooveWidth = 0.05;  // Ширина канавок

    // Вертикальные канавки
    const verticalGrooveGeometry = new THREE.BoxGeometry(grooveWidth, grooveDepth, 3.4);
    const groove1 = new THREE.Mesh(verticalGrooveGeometry, grooveMaterial)
    groove1.position.set(-0.48, 0.01 - grooveDepth / 2, 0.07);
    scene.add(groove1);

    const groove2 = groove1.clone();
    groove2.position.set(0.52, 0.01 - grooveDepth / 2, 0.07);
    scene.add(groove2);

    // Горизонтальные канавки
    const horizontalGrooveGeometry = new THREE.BoxGeometry(3.2, grooveDepth, grooveWidth);
    const groove3 = new THREE.Mesh(horizontalGrooveGeometry, grooveMaterial);
    groove3.position.set(0.01, 0.01 - grooveDepth / 2, -0.52);
    scene.add(groove3);

    const groove4 = groove3.clone();
    groove4.position.set(0.01, 0.01 - grooveDepth / 2, 0.64);
    scene.add(groove4);
}

// Создаем деревянный X
function createX(x, y) {
    const material = new THREE.MeshStandardMaterial({ map: stoneTexture });
    const geometry = new THREE.BoxGeometry(1, 0.24, 0.24);
    
    const x1 = new THREE.Mesh(geometry, material);
    x1.position.set(x * 1.1, -0.05, y * 1.1);
    x1.rotation.x = Math.PI / 2;
    x1.rotation.z = Math.PI / 4;

    const x2 = new THREE.Mesh(geometry, material);
    x2.position.set(x * 1.1, -0.05, y* 1.1);
    x2.rotation.x = Math.PI / 2;
    x2.rotation.z = -Math.PI / 4;

    scene.add(x1);
    scene.add(x2);
}

// Создаем деревянный O
function createO(x, y) {
    const material = new THREE.MeshStandardMaterial({ map: stoneTexture });
    const geometry = new THREE.TorusGeometry(0.32, 0.12, 40, 60);
    const o = new THREE.Mesh(geometry, material);
    o.position.set(x * 1.07, 0.05, y * 1.1 + 0.05);
    o.rotation.x = Math.PI / 2;
    scene.add(o);
}

// Загрузка звука падения
const stoneHitSound = new Audio('./stone.mp3');

// Высота доски для столкновения
const boardHeight = -0.05;

// Функция создания X с анимацией и звуком
function createXFalling(col, row) {
    const material = new THREE.MeshStandardMaterial({ map: stoneTexture });
    const geometry = new THREE.BoxGeometry(1, 0.24, 0.24);

    const x1 = new THREE.Mesh(geometry, material);
    const x2 = new THREE.Mesh(geometry, material);

    // Начальная позиция
    const startX = (col - 1) * 1.1;
    const startY = 5; // За пределами экрана (высоко над доской)
    const startZ = (row - 1) * 1.1;

    x1.position.set(startX, startY, startZ);
    x2.position.set(startX, startY, startZ);

    x1.rotation.x = Math.PI / 2;
    x1.rotation.z = Math.PI / 4;

    x2.rotation.x = Math.PI / 2;
    x2.rotation.z = -Math.PI / 4;

    scene.add(x1);
    scene.add(x2);

    // Флаг для предотвращения повторного воспроизведения звука
    let soundPlayed = false;

    // Анимация падения с отслеживанием
    gsap.to(x1.position, {
        y: boardHeight,
        duration: 1,
        ease: "bounce.out",
        onUpdate: () => {
            if (!soundPlayed && x1.position.y <= boardHeight + 0.1) { // Задаем небольшой "зазор" для точного момента
                stoneHitSound.play();
                soundPlayed = true;
            }
        }
    });
    gsap.to(x2.position, {
        y: boardHeight,
        duration: 1,
        ease: "bounce.out"
    });
}

// Функция создания O с анимацией и звуком
function createOFalling(col, row) {
    const material = new THREE.MeshStandardMaterial({ map: stoneTexture });
    const geometry = new THREE.TorusGeometry(0.32, 0.12, 40, 60);

    const o = new THREE.Mesh(geometry, material);

    // Начальная позиция
    const startX = (col - 1) * 1.07;
    const startY = 5; // За пределами экрана (высоко над доской)
    const startZ = (row - 1) * 1.1 + 0.05;

    o.position.set(startX, startY, startZ);
    o.rotation.x = Math.PI / 2;

    scene.add(o);

    // Флаг для предотвращения повторного воспроизведения звука
    let soundPlayed = false;

    // Анимация падения с отслеживанием
    gsap.to(o.position, {
        y: boardHeight,
        duration: 1,
        ease: "bounce.out",
        onUpdate: () => {
            if (!soundPlayed && o.position.y <= boardHeight + 0.1) {
                stoneHitSound.play();
                soundPlayed = true;
            }
        }
    });
}

// Освещение
const ambientLight = new THREE.AmbientLight(0x804000, 0.6);
scene.add(ambientLight);

// Усиленное боковое освещение
const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.2); // Увеличиваем интенсивность
directionalLight.position.set(3, 5, 2); // Позиция под углом для более выразительного теневого эффекта
directionalLight.castShadow = true;
scene.add(directionalLight);

// Raycaster и вектор для хранения позиции курсора
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Обработчик нажатия мыши
function onMouseClick(event) {
    // Преобразование позиции курсора из экранных координат в нормализованные координаты устройства (от -1 до +1)
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // Определяем пересечение луча с объектом (доской)
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(board);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        const localPoint = board.worldToLocal(intersect.point); // Получаем точку на доске в локальных координатах

        // Определяем ячейку 3x3
        const cellSize = 3.2 / 3; // Размер одной ячейки
        const row = Math.floor((localPoint.z + 3.2 / 2) / cellSize);
        const col = Math.floor((localPoint.x + 3.2 / 2) / cellSize);

        console.log(`Нажата ячейка: Row ${row}, Col ${col}`);
        move(col, row)        
    }
}

//игра
let turn = 'X';
let matrix = [['','',''],['','',''],['','','']];
function move(col, row){
   if (matrix[col][row]!='') return;

   matrix[col][row]=turn;

   if (turn === 'X') {
        createXFalling(col, row);	
        turn = 'O';
   } else {
        createOFalling(col, row);	
        turn = 'X';
   }

   checkWinner();
}

//проверка победителя
function checkWinner(){
   
}


// Функция рендеринга
function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

// Заполнение доски крестиками и ноликами
createBoard();

// Добавляем слушатель события нажатия мыши
window.addEventListener('click', onMouseClick, false);

animate();
</script>
</body>
</html>


