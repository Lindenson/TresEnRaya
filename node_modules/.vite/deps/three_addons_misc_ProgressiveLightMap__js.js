import {
  DoubleSide,
  FloatType,
  HalfFloatType,
  Mesh,
  MeshBasicMaterial,
  MeshPhongMaterial,
  PlaneGeometry,
  Scene,
  WebGLRenderTarget
} from "./chunk-UG26MVNH.js";

// node_modules/three/examples/jsm/libs/potpack.module.js
function potpack(boxes) {
  let area = 0;
  let maxWidth = 0;
  for (const box of boxes) {
    area += box.w * box.h;
    maxWidth = Math.max(maxWidth, box.w);
  }
  boxes.sort((a, b) => b.h - a.h);
  const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
  const spaces = [{ x: 0, y: 0, w: startWidth, h: Infinity }];
  let width = 0;
  let height = 0;
  for (const box of boxes) {
    for (let i = spaces.length - 1; i >= 0; i--) {
      const space = spaces[i];
      if (box.w > space.w || box.h > space.h) continue;
      box.x = space.x;
      box.y = space.y;
      height = Math.max(height, box.y + box.h);
      width = Math.max(width, box.x + box.w);
      if (box.w === space.w && box.h === space.h) {
        const last = spaces.pop();
        if (i < spaces.length) spaces[i] = last;
      } else if (box.h === space.h) {
        space.x += box.w;
        space.w -= box.w;
      } else if (box.w === space.w) {
        space.y += box.h;
        space.h -= box.h;
      } else {
        spaces.push({
          x: space.x + box.w,
          y: space.y,
          w: space.w - box.w,
          h: box.h
        });
        space.y += box.h;
        space.h -= box.h;
      }
      break;
    }
  }
  return {
    w: width,
    // container width
    h: height,
    // container height
    fill: area / (width * height) || 0
    // space utilization
  };
}

// node_modules/three/examples/jsm/misc/ProgressiveLightMap.js
var ProgressiveLightMap = class {
  constructor(renderer, res = 1024) {
    this.renderer = renderer;
    this.res = res;
    this.lightMapContainers = [];
    this.scene = new Scene();
    this.buffer1Active = false;
    this.firstUpdate = true;
    this.labelMesh = null;
    this.blurringPlane = null;
    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? HalfFloatType : FloatType;
    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, { type: format });
    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, { type: format });
    this.progressiveLightMap2.texture.channel = 1;
    this.uvMat = new MeshPhongMaterial();
    this.uvMat.uniforms = {};
    this.uvMat.onBeforeCompile = (shader) => {
      shader.vertexShader = "attribute vec2 uv1;\n#define USE_LIGHTMAP\n#define LIGHTMAP_UV uv1\n" + shader.vertexShader.slice(0, -1) + "	gl_Position = vec4((LIGHTMAP_UV - 0.5) * 2.0, 1.0, 1.0); }";
      const bodyStart = shader.fragmentShader.indexOf("void main() {");
      shader.fragmentShader = "#define USE_LIGHTMAP\n" + shader.fragmentShader.slice(0, bodyStart) + "	uniform sampler2D previousShadowMap;\n	uniform float averagingWindow;\n" + shader.fragmentShader.slice(bodyStart - 1, -1) + `
vec3 texelOld = texture2D(previousShadowMap, vLightMapUv).rgb;
				gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);
			}`;
      shader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture };
      shader.uniforms.averagingWindow = { value: 100 };
      this.uvMat.uniforms = shader.uniforms;
      this.uvMat.userData.shader = shader;
    };
  }
  /**
   * Sets these objects' materials' lightmaps and modifies their uv1's.
   * @param {Object3D} objects An array of objects and lights to set up your lightmap.
   */
  addObjectsToLightMap(objects) {
    this.uv_boxes = [];
    const padding = 3 / this.res;
    for (let ob = 0; ob < objects.length; ob++) {
      const object = objects[ob];
      if (object.isLight) {
        this.scene.attach(object);
        continue;
      }
      if (object.geometry.hasAttribute("uv") === false) {
        console.warn("THREE.ProgressiveLightMap: All lightmap objects need uvs.");
        continue;
      }
      if (this.blurringPlane === null) {
        this._initializeBlurPlane(this.res, this.progressiveLightMap1);
      }
      object.material.lightMap = this.progressiveLightMap2.texture;
      object.material.dithering = true;
      object.castShadow = true;
      object.receiveShadow = true;
      object.renderOrder = 1e3 + ob;
      this.uv_boxes.push({
        w: 1 + padding * 2,
        h: 1 + padding * 2,
        index: ob
      });
      this.lightMapContainers.push({ basicMat: object.material, object });
    }
    const dimensions = potpack(this.uv_boxes);
    this.uv_boxes.forEach((box) => {
      const uv1 = objects[box.index].geometry.getAttribute("uv").clone();
      for (let i = 0; i < uv1.array.length; i += uv1.itemSize) {
        uv1.array[i] = (uv1.array[i] + box.x + padding) / dimensions.w;
        uv1.array[i + 1] = (uv1.array[i + 1] + box.y + padding) / dimensions.h;
      }
      objects[box.index].geometry.setAttribute("uv1", uv1);
      objects[box.index].geometry.getAttribute("uv1").needsUpdate = true;
    });
  }
  /**
   * This function renders each mesh one at a time into their respective surface maps
   * @param {Camera} camera Standard Rendering Camera
   * @param {number} blendWindow When >1, samples will accumulate over time.
   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring
   */
  update(camera, blendWindow = 100, blurEdges = true) {
    if (this.blurringPlane === null) {
      return;
    }
    const oldTarget = this.renderer.getRenderTarget();
    this.blurringPlane.visible = blurEdges;
    for (let l = 0; l < this.lightMapContainers.length; l++) {
      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;
      this.scene.attach(this.lightMapContainers[l].object);
    }
    if (this.firstUpdate === true) {
      this.renderer.compile(this.scene, camera);
      this.firstUpdate = false;
    }
    for (let l = 0; l < this.lightMapContainers.length; l++) {
      this.uvMat.uniforms.averagingWindow = { value: blendWindow };
      this.lightMapContainers[l].object.material = this.uvMat;
      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled;
      this.lightMapContainers[l].object.frustumCulled = false;
    }
    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;
    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;
    this.renderer.setRenderTarget(activeMap);
    this.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture };
    this.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture };
    this.buffer1Active = !this.buffer1Active;
    this.renderer.render(this.scene, camera);
    for (let l = 0; l < this.lightMapContainers.length; l++) {
      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled;
      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat;
      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object);
    }
    this.renderer.setRenderTarget(oldTarget);
  }
  /** DEBUG
   * Draw the lightmap in the main scene.  Call this after adding the objects to it.
   * @param {boolean} visible Whether the debug plane should be visible
   * @param {Vector3} position Where the debug plane should be drawn
  */
  showDebugLightmap(visible, position = void 0) {
    if (this.lightMapContainers.length === 0) {
      console.warn("THREE.ProgressiveLightMap: Call .showDebugLightmap() after adding the objects.");
      return;
    }
    if (this.labelMesh === null) {
      const labelMaterial = new MeshBasicMaterial({ map: this.progressiveLightMap1.texture, side: DoubleSide });
      const labelGeometry = new PlaneGeometry(100, 100);
      this.labelMesh = new Mesh(labelGeometry, labelMaterial);
      this.labelMesh.position.y = 250;
      this.lightMapContainers[0].object.parent.add(this.labelMesh);
    }
    if (position !== void 0) {
      this.labelMesh.position.copy(position);
    }
    this.labelMesh.visible = visible;
  }
  /**
   * INTERNAL Creates the Blurring Plane
   * @param {number} res The square resolution of this object's lightMap.
   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.
   */
  _initializeBlurPlane(res, lightMap = null) {
    const blurMaterial = new MeshBasicMaterial();
    blurMaterial.uniforms = {
      previousShadowMap: { value: null },
      pixelOffset: { value: 1 / res },
      polygonOffset: true,
      polygonOffsetFactor: -1,
      polygonOffsetUnits: 3
    };
    blurMaterial.onBeforeCompile = (shader) => {
      shader.vertexShader = "#define USE_UV\n" + shader.vertexShader.slice(0, -1) + "	gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";
      const bodyStart = shader.fragmentShader.indexOf("void main() {");
      shader.fragmentShader = "#define USE_UV\n" + shader.fragmentShader.slice(0, bodyStart) + "	uniform sampler2D previousShadowMap;\n	uniform float pixelOffset;\n" + shader.fragmentShader.slice(bodyStart - 1, -1) + `	gl_FragColor.rgb = (
									texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +
									texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +
									texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +
									texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +
									texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +
									texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +
									texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +
									texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;
				}`;
      shader.uniforms.previousShadowMap = { value: lightMap.texture };
      shader.uniforms.pixelOffset = { value: 0.5 / res };
      blurMaterial.uniforms = shader.uniforms;
      blurMaterial.userData.shader = shader;
    };
    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);
    this.blurringPlane.name = "Blurring Plane";
    this.blurringPlane.frustumCulled = false;
    this.blurringPlane.renderOrder = 0;
    this.blurringPlane.material.depthWrite = false;
    this.scene.add(this.blurringPlane);
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.progressiveLightMap1.dispose();
    this.progressiveLightMap2.dispose();
    this.uvMat.dispose();
    if (this.blurringPlane !== null) {
      this.blurringPlane.geometry.dispose();
      this.blurringPlane.material.dispose();
    }
    if (this.labelMesh !== null) {
      this.labelMesh.geometry.dispose();
      this.labelMesh.material.dispose();
    }
  }
};
export {
  ProgressiveLightMap
};
/*! Bundled license information:

three/examples/jsm/libs/potpack.module.js:
  (**
   * potpack - by [@mourner](https://github.com/mourner)
   * 
   * A tiny JavaScript function for packing 2D rectangles into a near-square container, 
   * which is useful for generating CSS sprites and WebGL textures. Similar to 
   * [shelf-pack](https://github.com/mapbox/shelf-pack), but static (you can't add items 
   * once a layout is generated), and aims for maximal space utilization.
   *
   * A variation of algorithms used in [rectpack2D](https://github.com/TeamHypersomnia/rectpack2D)
   * and [bin-pack](https://github.com/bryanburgers/bin-pack), which are in turn based 
   * on [this article by Blackpawn](http://blackpawn.com/texts/lightmaps/default.html).
   * 
   * @license
   * ISC License
   * 
   * Copyright (c) 2018, Mapbox
   * 
   * Permission to use, copy, modify, and/or distribute this software for any purpose
   * with or without fee is hereby granted, provided that the above copyright notice
   * and this permission notice appear in all copies.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
   * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
   * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
   * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
   * THIS SOFTWARE.
   *)
*/
//# sourceMappingURL=three_addons_misc_ProgressiveLightMap__js.js.map
