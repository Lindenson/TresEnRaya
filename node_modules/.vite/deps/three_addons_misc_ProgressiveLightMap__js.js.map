{
  "version": 3,
  "sources": ["../../three/examples/jsm/libs/potpack.module.js", "../../three/examples/jsm/misc/ProgressiveLightMap.js"],
  "sourcesContent": ["/**\n * potpack - by [@mourner](https://github.com/mourner)\n * \n * A tiny JavaScript function for packing 2D rectangles into a near-square container, \n * which is useful for generating CSS sprites and WebGL textures. Similar to \n * [shelf-pack](https://github.com/mapbox/shelf-pack), but static (you can't add items \n * once a layout is generated), and aims for maximal space utilization.\n *\n * A variation of algorithms used in [rectpack2D](https://github.com/TeamHypersomnia/rectpack2D)\n * and [bin-pack](https://github.com/bryanburgers/bin-pack), which are in turn based \n * on [this article by Blackpawn](http://blackpawn.com/texts/lightmaps/default.html).\n * \n * @license\n * ISC License\n * \n * Copyright (c) 2018, Mapbox\n * \n * Permission to use, copy, modify, and/or distribute this software for any purpose\n * with or without fee is hereby granted, provided that the above copyright notice\n * and this permission notice appear in all copies.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n * THIS SOFTWARE.\n */\n\nfunction potpack(boxes) {\n\n\t// calculate total box area and maximum box width\n\tlet area = 0;\n\tlet maxWidth = 0;\n\t\n\tfor (const box of boxes) {\n\t\tarea += box.w * box.h;\n\t\tmaxWidth = Math.max(maxWidth, box.w);\n\t}\n\t\n\t// sort the boxes for insertion by height, descending\n\tboxes.sort((a, b) => b.h - a.h);\n\t\n\t// aim for a squarish resulting container,\n\t// slightly adjusted for sub-100% space utilization\n\tconst startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);\n\t\n\t// start with a single empty space, unbounded at the bottom\n\tconst spaces = [{x: 0, y: 0, w: startWidth, h: Infinity}];\n\t\n\tlet width = 0;\n\tlet height = 0;\n\t\n\tfor (const box of boxes) {\n\t\t// look through spaces backwards so that we check smaller spaces first\n\t\tfor (let i = spaces.length - 1; i >= 0; i--) {\n\t\t\tconst space = spaces[i];\n\t\t\t\n\t\t\t// look for empty spaces that can accommodate the current box\n\t\t\tif (box.w > space.w || box.h > space.h) continue;\n\t\t\t\n\t\t\t// found the space; add the box to its top-left corner\n\t\t\t// |-------|-------|\n\t\t\t// |  box  |       |\n\t\t\t// |_______|       |\n\t\t\t// |         space |\n\t\t\t// |_______________|\n\t\t\tbox.x = space.x;\n\t\t\tbox.y = space.y;\n\t\t\t\n\t\t\theight = Math.max(height, box.y + box.h);\n\t\t\twidth = Math.max(width, box.x + box.w);\n\t\t\t\n\t\t\tif (box.w === space.w && box.h === space.h) {\n\t\t\t\t// space matches the box exactly; remove it\n\t\t\t\tconst last = spaces.pop();\n\t\t\t\tif (i < spaces.length) spaces[i] = last;\n\t\t\t\n\t\t\t} else if (box.h === space.h) {\n\t\t\t\t// space matches the box height; update it accordingly\n\t\t\t\t// |-------|---------------|\n\t\t\t\t// |  box  | updated space |\n\t\t\t\t// |_______|_______________|\n\t\t\t\tspace.x += box.w;\n\t\t\t\tspace.w -= box.w;\n\t\t\t\n\t\t\t} else if (box.w === space.w) {\n\t\t\t\t// space matches the box width; update it accordingly\n\t\t\t\t// |---------------|\n\t\t\t\t// |      box      |\n\t\t\t\t// |_______________|\n\t\t\t\t// | updated space |\n\t\t\t\t// |_______________|\n\t\t\t\tspace.y += box.h;\n\t\t\t\tspace.h -= box.h;\n\t\t\t\n\t\t\t} else {\n\t\t\t\t// otherwise the box splits the space into two spaces\n\t\t\t\t// |-------|-----------|\n\t\t\t\t// |  box  | new space |\n\t\t\t\t// |_______|___________|\n\t\t\t\t// | updated space     |\n\t\t\t\t// |___________________|\n\t\t\t\tspaces.push({\n\t\t\t\t\tx: space.x + box.w,\n\t\t\t\t\ty: space.y,\n\t\t\t\t\tw: space.w - box.w,\n\t\t\t\t\th: box.h\n\t\t\t\t});\n\t\t\t\tspace.y += box.h;\n\t\t\t\tspace.h -= box.h;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn {\n\t\tw: width, // container width\n\t\th: height, // container height\n\t\tfill: (area / (width * height)) || 0 // space utilization\n\t};\n}\n\nexport { potpack };", "import { DoubleSide, FloatType, HalfFloatType, Mesh, MeshBasicMaterial, MeshPhongMaterial, PlaneGeometry, Scene, WebGLRenderTarget } from 'three';\nimport { potpack } from '../libs/potpack.module.js';\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer An instance of WebGLRenderer.\n * @param {number} res The side-long dimension of you total lightmap.\n */\nclass ProgressiveLightMap {\n\n\tconstructor( renderer, res = 1024 ) {\n\n\t\tthis.renderer = renderer;\n\t\tthis.res = res;\n\t\tthis.lightMapContainers = [];\n\t\tthis.scene = new Scene();\n\t\tthis.buffer1Active = false;\n\t\tthis.firstUpdate = true;\n\t\tthis.labelMesh = null;\n\t\tthis.blurringPlane = null;\n\n\t\t// Create the Progressive LightMap Texture\n\t\tconst format = /(Android|iPad|iPhone|iPod)/g.test( navigator.userAgent ) ? HalfFloatType : FloatType;\n\t\tthis.progressiveLightMap1 = new WebGLRenderTarget( this.res, this.res, { type: format } );\n\t\tthis.progressiveLightMap2 = new WebGLRenderTarget( this.res, this.res, { type: format } );\n\t\tthis.progressiveLightMap2.texture.channel = 1;\n\n\t\t// Inject some spicy new logic into a standard phong material\n\t\tthis.uvMat = new MeshPhongMaterial();\n\t\tthis.uvMat.uniforms = {};\n\t\tthis.uvMat.onBeforeCompile = ( shader ) => {\n\n\t\t\t// Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n\t\t\tshader.vertexShader =\n\t\t\t\t'attribute vec2 uv1;\\n' +\n\t\t\t\t'#define USE_LIGHTMAP\\n' +\n\t\t\t\t'#define LIGHTMAP_UV uv1\\n' +\n\t\t\t\tshader.vertexShader.slice( 0, - 1 ) +\n\t\t\t\t'\tgl_Position = vec4((LIGHTMAP_UV - 0.5) * 2.0, 1.0, 1.0); }';\n\n\t\t\t// Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\t\t\tconst bodyStart = shader.fragmentShader.indexOf( 'void main() {' );\n\t\t\tshader.fragmentShader =\n\t\t\t\t'#define USE_LIGHTMAP\\n' +\n\t\t\t\tshader.fragmentShader.slice( 0, bodyStart ) +\n\t\t\t\t'\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' +\n\t\t\t\tshader.fragmentShader.slice( bodyStart - 1, - 1 ) +\n\t\t\t\t`\\nvec3 texelOld = texture2D(previousShadowMap, vLightMapUv).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`;\n\n\t\t\t// Set the Previous Frame's Texture Buffer and Averaging Window\n\t\t\tshader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture };\n\t\t\tshader.uniforms.averagingWindow = { value: 100 };\n\n\t\t\tthis.uvMat.uniforms = shader.uniforms;\n\n\t\t\t// Set the new Shader to this\n\t\t\tthis.uvMat.userData.shader = shader;\n\n\t\t};\n\n\t}\n\n\t/**\n\t * Sets these objects' materials' lightmaps and modifies their uv1's.\n\t * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n\t */\n\taddObjectsToLightMap( objects ) {\n\n\t\t// Prepare list of UV bounding boxes for packing later...\n\t\tthis.uv_boxes = []; const padding = 3 / this.res;\n\n\t\tfor ( let ob = 0; ob < objects.length; ob ++ ) {\n\n\t\t\tconst object = objects[ ob ];\n\n\t\t\t// If this object is a light, simply add it to the internal scene\n\t\t\tif ( object.isLight ) {\n\n\t\t\t\tthis.scene.attach( object ); continue;\n\n\t\t\t}\n\n\t\t\tif ( object.geometry.hasAttribute( 'uv' ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.ProgressiveLightMap: All lightmap objects need uvs.' ); continue;\n\n\t\t\t}\n\n\t\t\tif ( this.blurringPlane === null ) {\n\n\t\t\t\tthis._initializeBlurPlane( this.res, this.progressiveLightMap1 );\n\n\t\t\t}\n\n\t\t\t// Apply the lightmap to the object\n\t\t\tobject.material.lightMap = this.progressiveLightMap2.texture;\n\t\t\tobject.material.dithering = true;\n\t\t\tobject.castShadow = true;\n\t\t\tobject.receiveShadow = true;\n\t\t\tobject.renderOrder = 1000 + ob;\n\n\t\t\t// Prepare UV boxes for potpack\n\t\t\t// TODO: Size these by object surface area\n\t\t\tthis.uv_boxes.push( { w: 1 + ( padding * 2 ),\n\t\t\t\t\t\t\t\t  h: 1 + ( padding * 2 ), index: ob } );\n\n\t\t\tthis.lightMapContainers.push( { basicMat: object.material, object: object } );\n\n\t\t}\n\n\t\t// Pack the objects' lightmap UVs into the same global space\n\t\tconst dimensions = potpack( this.uv_boxes );\n\t\tthis.uv_boxes.forEach( ( box ) => {\n\n\t\t\tconst uv1 = objects[ box.index ].geometry.getAttribute( 'uv' ).clone();\n\t\t\tfor ( let i = 0; i < uv1.array.length; i += uv1.itemSize ) {\n\n\t\t\t\tuv1.array[ i ] = ( uv1.array[ i ] + box.x + padding ) / dimensions.w;\n\t\t\t\tuv1.array[ i + 1 ] = ( uv1.array[ i + 1 ] + box.y + padding ) / dimensions.h;\n\n\t\t\t}\n\n\t\t\tobjects[ box.index ].geometry.setAttribute( 'uv1', uv1 );\n\t\t\tobjects[ box.index ].geometry.getAttribute( 'uv1' ).needsUpdate = true;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * This function renders each mesh one at a time into their respective surface maps\n\t * @param {Camera} camera Standard Rendering Camera\n\t * @param {number} blendWindow When >1, samples will accumulate over time.\n\t * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n\t */\n\tupdate( camera, blendWindow = 100, blurEdges = true ) {\n\n\t\tif ( this.blurringPlane === null ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Store the original Render Target\n\t\tconst oldTarget = this.renderer.getRenderTarget();\n\n\t\t// The blurring plane applies blur to the seams of the lightmap\n\t\tthis.blurringPlane.visible = blurEdges;\n\n\t\t// Steal the Object3D from the real world to our special dimension\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.lightMapContainers[ l ].object.oldScene =\n\t\t\t\tthis.lightMapContainers[ l ].object.parent;\n\t\t\tthis.scene.attach( this.lightMapContainers[ l ].object );\n\n\t\t}\n\n\t\t// Initialize everything\n\t\tif ( this.firstUpdate === true ) {\n\n\t\t\tthis.renderer.compile( this.scene, camera );\n\t\t\tthis.firstUpdate = false;\n\n\t\t}\n\n\t\t// Set each object's material to the UV Unwrapped Surface Mapping Version\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.uvMat.uniforms.averagingWindow = { value: blendWindow };\n\t\t\tthis.lightMapContainers[ l ].object.material = this.uvMat;\n\t\t\tthis.lightMapContainers[ l ].object.oldFrustumCulled =\n\t\t\t\tthis.lightMapContainers[ l ].object.frustumCulled;\n\t\t\tthis.lightMapContainers[ l ].object.frustumCulled = false;\n\n\t\t}\n\n\t\t// Ping-pong two surface buffers for reading/writing\n\t\tconst activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n\t\tconst inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n\n\t\t// Render the object's surface maps\n\t\tthis.renderer.setRenderTarget( activeMap );\n\t\tthis.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture };\n\t\tthis.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture };\n\t\tthis.buffer1Active = ! this.buffer1Active;\n\t\tthis.renderer.render( this.scene, camera );\n\n\t\t// Restore the object's Real-time Material and add it back to the original world\n\t\tfor ( let l = 0; l < this.lightMapContainers.length; l ++ ) {\n\n\t\t\tthis.lightMapContainers[ l ].object.frustumCulled =\n\t\t\t\tthis.lightMapContainers[ l ].object.oldFrustumCulled;\n\t\t\tthis.lightMapContainers[ l ].object.material = this.lightMapContainers[ l ].basicMat;\n\t\t\tthis.lightMapContainers[ l ].object.oldScene.attach( this.lightMapContainers[ l ].object );\n\n\t\t}\n\n\t\t// Restore the original Render Target\n\t\tthis.renderer.setRenderTarget( oldTarget );\n\n\t}\n\n\t/** DEBUG\n\t * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n\t * @param {boolean} visible Whether the debug plane should be visible\n\t * @param {Vector3} position Where the debug plane should be drawn\n\t*/\n\tshowDebugLightmap( visible, position = undefined ) {\n\n\t\tif ( this.lightMapContainers.length === 0 ) {\n\n\t\t\tconsole.warn( 'THREE.ProgressiveLightMap: Call .showDebugLightmap() after adding the objects.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.labelMesh === null ) {\n\n\t\t\tconst labelMaterial = new MeshBasicMaterial( { map: this.progressiveLightMap1.texture, side: DoubleSide } );\n\t\t\tconst labelGeometry = new PlaneGeometry( 100, 100 );\n\t\t\tthis.labelMesh = new Mesh( labelGeometry, labelMaterial );\n\t\t\tthis.labelMesh.position.y = 250;\n\t\t\tthis.lightMapContainers[ 0 ].object.parent.add( this.labelMesh );\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.labelMesh.position.copy( position );\n\n\t\t}\n\n\t\tthis.labelMesh.visible = visible;\n\n\t}\n\n\t/**\n\t * INTERNAL Creates the Blurring Plane\n\t * @param {number} res The square resolution of this object's lightMap.\n\t * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n\t */\n\t_initializeBlurPlane( res, lightMap = null ) {\n\n\t\tconst blurMaterial = new MeshBasicMaterial();\n\t\tblurMaterial.uniforms = { previousShadowMap: { value: null },\n\t\t\t\t\t\t\t\t  pixelOffset: { value: 1.0 / res },\n\t\t\t\t\t\t\t\t  polygonOffset: true, polygonOffsetFactor: - 1, polygonOffsetUnits: 3.0 };\n\t\tblurMaterial.onBeforeCompile = ( shader ) => {\n\n\t\t\t// Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n\t\t\tshader.vertexShader =\n\t\t\t\t'#define USE_UV\\n' +\n\t\t\t\tshader.vertexShader.slice( 0, - 1 ) +\n\t\t\t\t'\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }';\n\n\t\t\t// Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n\t\t\tconst bodyStart\t= shader.fragmentShader.indexOf( 'void main() {' );\n\t\t\tshader.fragmentShader =\n\t\t\t\t'#define USE_UV\\n' +\n\t\t\t\tshader.fragmentShader.slice( 0, bodyStart ) +\n\t\t\t\t'\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' +\n\t\t\t\tshader.fragmentShader.slice( bodyStart - 1, - 1 ) +\n\t\t\t\t\t`\tgl_FragColor.rgb = (\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t\t\t\t\t\t\ttexture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t\t\t}`;\n\n\t\t\t// Set the LightMap Accumulation Buffer\n\t\t\tshader.uniforms.previousShadowMap = { value: lightMap.texture };\n\t\t\tshader.uniforms.pixelOffset = { value: 0.5 / res };\n\t\t\tblurMaterial.uniforms = shader.uniforms;\n\n\t\t\t// Set the new Shader to this\n\t\t\tblurMaterial.userData.shader = shader;\n\n\t\t};\n\n\t\tthis.blurringPlane = new Mesh( new PlaneGeometry( 1, 1 ), blurMaterial );\n\t\tthis.blurringPlane.name = 'Blurring Plane';\n\t\tthis.blurringPlane.frustumCulled = false;\n\t\tthis.blurringPlane.renderOrder = 0;\n\t\tthis.blurringPlane.material.depthWrite = false;\n\t\tthis.scene.add( this.blurringPlane );\n\n\t}\n\n\t/**\n\t * Frees all internal resources.\n\t */\n\tdispose() {\n\n\t\tthis.progressiveLightMap1.dispose();\n\t\tthis.progressiveLightMap2.dispose();\n\n\t\tthis.uvMat.dispose();\n\n\t\tif ( this.blurringPlane !== null ) {\n\n\t\t\tthis.blurringPlane.geometry.dispose();\n\t\t\tthis.blurringPlane.material.dispose();\n\n\t\t}\n\n\t\tif ( this.labelMesh !== null ) {\n\n\t\t\tthis.labelMesh.geometry.dispose();\n\t\t\tthis.labelMesh.material.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport { ProgressiveLightMap };\n"],
  "mappings": ";;;;;;;;;;;;;AA8BA,SAAS,QAAQ,OAAO;AAGvB,MAAI,OAAO;AACX,MAAI,WAAW;AAEf,aAAW,OAAO,OAAO;AACxB,YAAQ,IAAI,IAAI,IAAI;AACpB,eAAW,KAAK,IAAI,UAAU,IAAI,CAAC;AAAA,EACpC;AAGA,QAAM,KAAK,CAAC,GAAG,MAAM,EAAE,IAAI,EAAE,CAAC;AAI9B,QAAM,aAAa,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK,OAAO,IAAI,CAAC,GAAG,QAAQ;AAGvE,QAAM,SAAS,CAAC,EAAC,GAAG,GAAG,GAAG,GAAG,GAAG,YAAY,GAAG,SAAQ,CAAC;AAExD,MAAI,QAAQ;AACZ,MAAI,SAAS;AAEb,aAAW,OAAO,OAAO;AAExB,aAAS,IAAI,OAAO,SAAS,GAAG,KAAK,GAAG,KAAK;AAC5C,YAAM,QAAQ,OAAO,CAAC;AAGtB,UAAI,IAAI,IAAI,MAAM,KAAK,IAAI,IAAI,MAAM,EAAG;AAQxC,UAAI,IAAI,MAAM;AACd,UAAI,IAAI,MAAM;AAEd,eAAS,KAAK,IAAI,QAAQ,IAAI,IAAI,IAAI,CAAC;AACvC,cAAQ,KAAK,IAAI,OAAO,IAAI,IAAI,IAAI,CAAC;AAErC,UAAI,IAAI,MAAM,MAAM,KAAK,IAAI,MAAM,MAAM,GAAG;AAE3C,cAAM,OAAO,OAAO,IAAI;AACxB,YAAI,IAAI,OAAO,OAAQ,QAAO,CAAC,IAAI;AAAA,MAEpC,WAAW,IAAI,MAAM,MAAM,GAAG;AAK7B,cAAM,KAAK,IAAI;AACf,cAAM,KAAK,IAAI;AAAA,MAEhB,WAAW,IAAI,MAAM,MAAM,GAAG;AAO7B,cAAM,KAAK,IAAI;AACf,cAAM,KAAK,IAAI;AAAA,MAEhB,OAAO;AAON,eAAO,KAAK;AAAA,UACX,GAAG,MAAM,IAAI,IAAI;AAAA,UACjB,GAAG,MAAM;AAAA,UACT,GAAG,MAAM,IAAI,IAAI;AAAA,UACjB,GAAG,IAAI;AAAA,QACR,CAAC;AACD,cAAM,KAAK,IAAI;AACf,cAAM,KAAK,IAAI;AAAA,MAChB;AACA;AAAA,IACD;AAAA,EACD;AAEA,SAAO;AAAA,IACN,GAAG;AAAA;AAAA,IACH,GAAG;AAAA;AAAA,IACH,MAAO,QAAQ,QAAQ,WAAY;AAAA;AAAA,EACpC;AACD;;;ACvGA,IAAM,sBAAN,MAA0B;AAAA,EAEzB,YAAa,UAAU,MAAM,MAAO;AAEnC,SAAK,WAAW;AAChB,SAAK,MAAM;AACX,SAAK,qBAAqB,CAAC;AAC3B,SAAK,QAAQ,IAAI,MAAM;AACvB,SAAK,gBAAgB;AACrB,SAAK,cAAc;AACnB,SAAK,YAAY;AACjB,SAAK,gBAAgB;AAGrB,UAAM,SAAS,8BAA8B,KAAM,UAAU,SAAU,IAAI,gBAAgB;AAC3F,SAAK,uBAAuB,IAAI,kBAAmB,KAAK,KAAK,KAAK,KAAK,EAAE,MAAM,OAAO,CAAE;AACxF,SAAK,uBAAuB,IAAI,kBAAmB,KAAK,KAAK,KAAK,KAAK,EAAE,MAAM,OAAO,CAAE;AACxF,SAAK,qBAAqB,QAAQ,UAAU;AAG5C,SAAK,QAAQ,IAAI,kBAAkB;AACnC,SAAK,MAAM,WAAW,CAAC;AACvB,SAAK,MAAM,kBAAkB,CAAE,WAAY;AAG1C,aAAO,eACN,yEAGA,OAAO,aAAa,MAAO,GAAG,EAAI,IAClC;AAGD,YAAM,YAAY,OAAO,eAAe,QAAS,eAAgB;AACjE,aAAO,iBACN,2BACA,OAAO,eAAe,MAAO,GAAG,SAAU,IAC1C,6EACA,OAAO,eAAe,MAAO,YAAY,GAAG,EAAI,IAChD;AAAA;AAAA;AAAA;AAKD,aAAO,SAAS,oBAAoB,EAAE,OAAO,KAAK,qBAAqB,QAAQ;AAC/E,aAAO,SAAS,kBAAkB,EAAE,OAAO,IAAI;AAE/C,WAAK,MAAM,WAAW,OAAO;AAG7B,WAAK,MAAM,SAAS,SAAS;AAAA,IAE9B;AAAA,EAED;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,qBAAsB,SAAU;AAG/B,SAAK,WAAW,CAAC;AAAG,UAAM,UAAU,IAAI,KAAK;AAE7C,aAAU,KAAK,GAAG,KAAK,QAAQ,QAAQ,MAAQ;AAE9C,YAAM,SAAS,QAAS,EAAG;AAG3B,UAAK,OAAO,SAAU;AAErB,aAAK,MAAM,OAAQ,MAAO;AAAG;AAAA,MAE9B;AAEA,UAAK,OAAO,SAAS,aAAc,IAAK,MAAM,OAAQ;AAErD,gBAAQ,KAAM,2DAA4D;AAAG;AAAA,MAE9E;AAEA,UAAK,KAAK,kBAAkB,MAAO;AAElC,aAAK,qBAAsB,KAAK,KAAK,KAAK,oBAAqB;AAAA,MAEhE;AAGA,aAAO,SAAS,WAAW,KAAK,qBAAqB;AACrD,aAAO,SAAS,YAAY;AAC5B,aAAO,aAAa;AACpB,aAAO,gBAAgB;AACvB,aAAO,cAAc,MAAO;AAI5B,WAAK,SAAS,KAAM;AAAA,QAAE,GAAG,IAAM,UAAU;AAAA,QAClC,GAAG,IAAM,UAAU;AAAA,QAAK,OAAO;AAAA,MAAG,CAAE;AAE3C,WAAK,mBAAmB,KAAM,EAAE,UAAU,OAAO,UAAU,OAAe,CAAE;AAAA,IAE7E;AAGA,UAAM,aAAa,QAAS,KAAK,QAAS;AAC1C,SAAK,SAAS,QAAS,CAAE,QAAS;AAEjC,YAAM,MAAM,QAAS,IAAI,KAAM,EAAE,SAAS,aAAc,IAAK,EAAE,MAAM;AACrE,eAAU,IAAI,GAAG,IAAI,IAAI,MAAM,QAAQ,KAAK,IAAI,UAAW;AAE1D,YAAI,MAAO,CAAE,KAAM,IAAI,MAAO,CAAE,IAAI,IAAI,IAAI,WAAY,WAAW;AACnE,YAAI,MAAO,IAAI,CAAE,KAAM,IAAI,MAAO,IAAI,CAAE,IAAI,IAAI,IAAI,WAAY,WAAW;AAAA,MAE5E;AAEA,cAAS,IAAI,KAAM,EAAE,SAAS,aAAc,OAAO,GAAI;AACvD,cAAS,IAAI,KAAM,EAAE,SAAS,aAAc,KAAM,EAAE,cAAc;AAAA,IAEnE,CAAE;AAAA,EAEH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAQ,QAAQ,cAAc,KAAK,YAAY,MAAO;AAErD,QAAK,KAAK,kBAAkB,MAAO;AAElC;AAAA,IAED;AAGA,UAAM,YAAY,KAAK,SAAS,gBAAgB;AAGhD,SAAK,cAAc,UAAU;AAG7B,aAAU,IAAI,GAAG,IAAI,KAAK,mBAAmB,QAAQ,KAAO;AAE3D,WAAK,mBAAoB,CAAE,EAAE,OAAO,WACnC,KAAK,mBAAoB,CAAE,EAAE,OAAO;AACrC,WAAK,MAAM,OAAQ,KAAK,mBAAoB,CAAE,EAAE,MAAO;AAAA,IAExD;AAGA,QAAK,KAAK,gBAAgB,MAAO;AAEhC,WAAK,SAAS,QAAS,KAAK,OAAO,MAAO;AAC1C,WAAK,cAAc;AAAA,IAEpB;AAGA,aAAU,IAAI,GAAG,IAAI,KAAK,mBAAmB,QAAQ,KAAO;AAE3D,WAAK,MAAM,SAAS,kBAAkB,EAAE,OAAO,YAAY;AAC3D,WAAK,mBAAoB,CAAE,EAAE,OAAO,WAAW,KAAK;AACpD,WAAK,mBAAoB,CAAE,EAAE,OAAO,mBACnC,KAAK,mBAAoB,CAAE,EAAE,OAAO;AACrC,WAAK,mBAAoB,CAAE,EAAE,OAAO,gBAAgB;AAAA,IAErD;AAGA,UAAM,YAAY,KAAK,gBAAgB,KAAK,uBAAuB,KAAK;AACxE,UAAM,cAAc,KAAK,gBAAgB,KAAK,uBAAuB,KAAK;AAG1E,SAAK,SAAS,gBAAiB,SAAU;AACzC,SAAK,MAAM,SAAS,oBAAoB,EAAE,OAAO,YAAY,QAAQ;AACrE,SAAK,cAAc,SAAS,SAAS,oBAAoB,EAAE,OAAO,YAAY,QAAQ;AACtF,SAAK,gBAAgB,CAAE,KAAK;AAC5B,SAAK,SAAS,OAAQ,KAAK,OAAO,MAAO;AAGzC,aAAU,IAAI,GAAG,IAAI,KAAK,mBAAmB,QAAQ,KAAO;AAE3D,WAAK,mBAAoB,CAAE,EAAE,OAAO,gBACnC,KAAK,mBAAoB,CAAE,EAAE,OAAO;AACrC,WAAK,mBAAoB,CAAE,EAAE,OAAO,WAAW,KAAK,mBAAoB,CAAE,EAAE;AAC5E,WAAK,mBAAoB,CAAE,EAAE,OAAO,SAAS,OAAQ,KAAK,mBAAoB,CAAE,EAAE,MAAO;AAAA,IAE1F;AAGA,SAAK,SAAS,gBAAiB,SAAU;AAAA,EAE1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,kBAAmB,SAAS,WAAW,QAAY;AAElD,QAAK,KAAK,mBAAmB,WAAW,GAAI;AAE3C,cAAQ,KAAM,gFAAiF;AAE/F;AAAA,IAED;AAEA,QAAK,KAAK,cAAc,MAAO;AAE9B,YAAM,gBAAgB,IAAI,kBAAmB,EAAE,KAAK,KAAK,qBAAqB,SAAS,MAAM,WAAW,CAAE;AAC1G,YAAM,gBAAgB,IAAI,cAAe,KAAK,GAAI;AAClD,WAAK,YAAY,IAAI,KAAM,eAAe,aAAc;AACxD,WAAK,UAAU,SAAS,IAAI;AAC5B,WAAK,mBAAoB,CAAE,EAAE,OAAO,OAAO,IAAK,KAAK,SAAU;AAAA,IAEhE;AAEA,QAAK,aAAa,QAAY;AAE7B,WAAK,UAAU,SAAS,KAAM,QAAS;AAAA,IAExC;AAEA,SAAK,UAAU,UAAU;AAAA,EAE1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qBAAsB,KAAK,WAAW,MAAO;AAE5C,UAAM,eAAe,IAAI,kBAAkB;AAC3C,iBAAa,WAAW;AAAA,MAAE,mBAAmB,EAAE,OAAO,KAAK;AAAA,MACnD,aAAa,EAAE,OAAO,IAAM,IAAI;AAAA,MAChC,eAAe;AAAA,MAAM,qBAAqB;AAAA,MAAK,oBAAoB;AAAA,IAAI;AAC/E,iBAAa,kBAAkB,CAAE,WAAY;AAG5C,aAAO,eACN,qBACA,OAAO,aAAa,MAAO,GAAG,EAAI,IAClC;AAGD,YAAM,YAAY,OAAO,eAAe,QAAS,eAAgB;AACjE,aAAO,iBACN,qBACA,OAAO,eAAe,MAAO,GAAG,SAAU,IAC1C,yEACA,OAAO,eAAe,MAAO,YAAY,GAAG,EAAI,IAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYF,aAAO,SAAS,oBAAoB,EAAE,OAAO,SAAS,QAAQ;AAC9D,aAAO,SAAS,cAAc,EAAE,OAAO,MAAM,IAAI;AACjD,mBAAa,WAAW,OAAO;AAG/B,mBAAa,SAAS,SAAS;AAAA,IAEhC;AAEA,SAAK,gBAAgB,IAAI,KAAM,IAAI,cAAe,GAAG,CAAE,GAAG,YAAa;AACvE,SAAK,cAAc,OAAO;AAC1B,SAAK,cAAc,gBAAgB;AACnC,SAAK,cAAc,cAAc;AACjC,SAAK,cAAc,SAAS,aAAa;AACzC,SAAK,MAAM,IAAK,KAAK,aAAc;AAAA,EAEpC;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;AAET,SAAK,qBAAqB,QAAQ;AAClC,SAAK,qBAAqB,QAAQ;AAElC,SAAK,MAAM,QAAQ;AAEnB,QAAK,KAAK,kBAAkB,MAAO;AAElC,WAAK,cAAc,SAAS,QAAQ;AACpC,WAAK,cAAc,SAAS,QAAQ;AAAA,IAErC;AAEA,QAAK,KAAK,cAAc,MAAO;AAE9B,WAAK,UAAU,SAAS,QAAQ;AAChC,WAAK,UAAU,SAAS,QAAQ;AAAA,IAEjC;AAAA,EAED;AAED;",
  "names": []
}
